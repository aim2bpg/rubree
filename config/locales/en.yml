en:
  application:
    title: "Rubree - A Ruby regular expression editor inspired by Rubular"
    description: >-
      Rubree is a Ruby regular expression editor inspired by Rubular. Quickly test and
      visualize your regex patterns in an intuitive interface.
    site_name: Rubree
  regular_expressions:
    header:
      subtitle: Ruby regular expression editor
      try_example: Try this example
      try_random_tooltip: Try a random example
      open_github: "Open Rubree repository on GitHub"
      github_star: "If you like Rubree, please star ☆"
      examples: Examples
      categories_label: Categories
      examples_label: Examples
      open_examples: "Select a category on the left to view examples."
      button: Regex Examples
      toggle_locale: Toggle language
      lang_label: LANG
    form:
      your_regular_expression: 'Your regular expression:'
      options: 'Options:'
      your_test_string: 'Your test string:'
      substitution: 'Substitution:'
    results:
      railroad_diagram: 'Railroad diagram:'
      railroad_diagram_placeholder: Railroad diagram will appear here
      view_full_diagram: View full diagram
      copy_diagram_png: Copy diagram as PNG
      close: Close
      copied: Copied!
      test_result_placeholder: Regexp test result will appear here
      please_enter: Please enter a regular expression pattern and a test string.
      match_result_label: 'Match result:'
      invalid_regex: Invalid regular expression.
      no_matches: No matches.
      match_groups: 'Match groups:'
      match_number: Match %{number}
      substitution:
        label: 'Substitution:'
        no_substitution: No substitution was performed or no match was found.
      ruby_code_label: 'Ruby code:'
      show: Show
      hide: Hide
      copy_ruby_code: Copy Ruby code
      avg_of_runs: "(avg of %{count} runs)"
      wrap_words: Wrap words
      show_invisibles: Show invisibles
    categories:
      pattern-matching-examples:
        short: Patterns
        description: Named capture patterns with multiline input, including query and fragment for URL, and non-greedy capture for log and YAML lines.
        examples:
          0:
            pattern: "^(?<local_part>[a-zA-Z0-9.!#$%&'*+\\/=?^_`{|}~-]+)@(?<domain_name>([a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)(?:\\.(?:[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?))*)$"
            test: |-
              test@example.com
              foo.bar@sub.domain.org
              bad@.com
              user@site.co.jp
              wrong@site,com
            result: match
            options: m
            substitution: ''
            description: "^(?<local_part>[a-zA-Z0-9.!#$%&'*+\\/=?^_`{|}~-]+)@(?<domain_name>([a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)(?:\\.(?:[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?))*)$ — matches at the start and end of the string."
          1:
            pattern: "^(?<scheme>https?|ftp):\\/\\/(?<host>[a-zA-Z0-9.-]+)(?<path>\\/[^\\s?#]*)?(\\?(?<query>[^#\\s]*))?(#(?<fragment>\\S+))?$"
            test: |-
              https://example.com
              https://example.com/path?arg=1
              ftp://files.net/path#section
              http://localhost
              invalid_url
            result: match
            options: m
            substitution: ''
            description: "^(?<scheme>https?|ftp):\\/\\/(?<host>[a-zA-Z0-9.-]+)(?<path>\\/[^\\s?#]*)?(\\?(?<query>[^#\\s]*))?(#(?<fragment>\\S+))?$ — matches at the start and end of the string."
          2:
            pattern: "^(?<octet1>25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)\\.(?<octet2>25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)\\.(?<octet3>25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)\\.(?<octet4>25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)$"
            test: |-
              192.168.0.1
              255.255.255.255
              256.100.100.100
              10.0.0.1
              0.0.0.0
            result: match
            options: m
            substitution: ''
            description: "^(?<octet1>25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)\\.(?<octet2>25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)\\.(?<octet3>25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)\\.(?<octet4>25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)$ — matches at the start and end of the string."
          3:
            pattern: "^(?<block1>[0-9a-fA-F]{1,4}):(?<block2>[0-9a-fA-F]{1,4}):(?<block3>[0-9a-fA-F]{1,4}):(?<block4>[0-9a-fA-F]{1,4}):(?<block5>[0-9a-fA-F]{1,4}):(?<block6>[0-9a-fA-F]{1,4}):(?<block7>[0-9a-fA-F]{1,4}):(?<block8>[0-9a-fA-F]{1,4})$|^(?<compressed_address>([0-9a-fA-F]{1,4}:){1,7}:)$"
            test: |-
              2001:0db8:85a3:0000:0000:8a2e:0370:7334
              2001:db8::8a2e:370:7334
              ::1
              invalid::ip
              fe80::1ff:fe23:4567:890a
            result: match
            options: m
            substitution: ''
            description: "^(?<block1>[0-9a-fA-F]{1,4}):(?<block2>[0-9a-fA-F]{1,4}):(?<block3>[0-9a-fA-F]{1,4}):(?<block4>[0-9a-fA-F]{1,4}):(?<block5>[0-9a-fA-F]{1,4}):(?<block6>[0-9a-fA-F]{1,4}):(?<block7>[0-9a-fA-F]{1,4}):(?<block8>[0-9a-fA-F]{1,4})$|^(?<compressed_address>([0-9a-fA-F]{1,4}:){1,7}:)$ — matches at the start and end of the string."
          4:
            pattern: "^\\[(?<timestamp>\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2})\\] \\[(?<level>ERROR)\\] (?<message>.+?)$"
            test: |-
              [2025-08-17 12:00:00] [INFO] Start
              [2025-08-17 12:01:00] [ERROR] Failed
              [2025-08-17 12:02:00] [WARN] Low
              [2025-08-17 12:03:00] [ERROR] Crash
              [2025-08-17 12:04:00] [INFO] Done
            result: match
            options: m
            substitution: ''
            description: "^\\[(?<timestamp>\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2})\\] \\[(?<level>ERROR)\\] (?<message>.+?)$ — matches at the start and end of the string."
          5:
            pattern: "^(?<parent>[a-zA-Z0-9_-]+):\\n(?: {2}(?<key1>[a-zA-Z0-9_-]+): (?<value1>.+)\\n){3}\\s*(?: {2}(?<key2>[a-zA-Z0-9_-]+): (?<value2>.+)\\n){3}?"
            test: |-
              parent1:
                name: Alice
                age: 30
                city: Tokyo
              parent2:
                hobby: hiking
                pet: dog
                food: sushi
              invalid line
            result: match
            options: m
            substitution: ''
            description: "^(?<parent>[a-zA-Z0-9_-]+):\\n(?: {2}(?<key1>[a-zA-Z0-9_-]+): (?<value1>.+)\\n){3}\\s*(?: {2}(?<key2>[a-zA-Z0-9_-]+): (?<value2>.+)\\n){3}? — matches at the start of the string."
      basic-operations:
        short: Basics
        description: 'Basic operations: Concatenation, Alternation, Repeat (no syntax sugar).'
        examples:
          0:
            pattern: abc
            test: abc
            result: match
            options: ''
            substitution: ''
            description: Concatenation abc — matches the sequence 'a', 'b', 'c'.
          1:
            pattern: ab
            test: cab
            result: match
            options: ''
            substitution: ''
            description: Concatenation ab — matches the sequence 'a', 'b'.
          2:
            pattern: ab
            test: acb
            result: no-match
            options: ''
            substitution: ''
            description: Concatenation ab — does not match when characters are not in sequence.
          3:
            pattern: a|b|c
            test: abc
            result: match
            options: ''
            substitution: ''
            description: Alternation a|b|c — matches one of the alternatives in the pattern.
          4:
            pattern: a|b*
            test: bbb
            result: match
            options: ''
            substitution: ''
            description: Alternation + Quantifier a|b* — matches one of the alternatives in the pattern.
          5:
            pattern: a|b*
            test: aaa
            result: match
            options: ''
            substitution: ''
            description: Alternation + Quantifier a|b* — matches one of the alternatives in the pattern.
          6:
            pattern: a*
            test: a
            result: match
            options: ''
            substitution: ''
            description: Kleene Star a* — Matches according to its quantifier.
          7:
            pattern: a*
            test: aaa
            result: match
            options: ''
            substitution: ''
            description: Kleene Star a* — Matches according to its quantifier.
          8:
            pattern: a*
            test: bbb
            result: match
            options: ''
            substitution: ''
            description: Kleene Star a* — Matches according to its quantifier.
          9:
            pattern: ab|cd
            test: cd
            result: match
            options: ''
            substitution: ''
            description: Concatenation + Alternation ab|cd — matches one of the alternatives in the pattern.
          10:
            pattern: a|b*
            test: a
            result: match
            options: ''
            substitution: ''
            description: Alternation + Quantifier a|b* — matches one of the alternatives in the pattern.
          11:
            pattern: a*bc
            test: aaabc
            result: match
            options: ''
            substitution: ''
            description: Concatenation + Quantifier a*bc — matches according to its quantifier.
      syntax-sugar:
        short: Sugar
        description: Quantifiers, dot, character classes, escapes, anchors, and more.
        examples:
          0:
            pattern: a+
            test: aaab
            result: match
            options: ''
            substitution: ''
            description: Quantifier a+ — One or more 'a'.
          1:
            pattern: a?
            test: apple
            result: match
            options: ''
            substitution: ''
            description: Quantifier a? — Zero or one 'a'.
          2:
            pattern: a{2,4}
            test: aaabc
            result: match
            options: ''
            substitution: ''
            description: Range quantifier a{2,4} — matches 2–4 'a'.
          3:
            pattern: a.c
            test: abc
            result: match
            options: ''
            substitution: ''
            description: Dot a.c — Dot matches any single character between 'a' and 'c'.
          4:
            pattern: "[a-z]"
            test: Hello World
            result: match
            options: ''
            substitution: ''
            description: Character class [a-z] — matches any single lowercase letter.
          5:
            pattern: "[a-z-]"
            test: Hello-World
            result: match
            options: ''
            substitution: ''
            description: Character class [a-z-] — character class with range and a literal hyphen.
          6:
            pattern: "[^a-z]"
            test: Hello World
            result: match
            options: ''
            substitution: ''
            description: Nagated class [^a-z] — matches characters not in a–z.
          7:
            pattern: \t
            test: a	b
            result: match
            options: ''
            substitution: ''
            description: Escape sequence \t — matches a tab between 'a' and 'b'.
          8:
            pattern: ^
            test: abc
            result: match
            options: ''
            substitution: ''
            description: Anchor ^ — matches at the start of the string.
          9:
            pattern: $
            test: abc
            result: match
            options: ''
            substitution: ''
            description: Anchor $ — matches at the end of the string.
          10:
            pattern: \b
            test: Hello-World
            result: match
            options: ''
            substitution: ''
            description: Word boundary \b — matches 'word' as a whole word.
          11:
            pattern: \B
            test: bend
            result: match
            options: ''
            substitution: ''
            description: Non word boundary \B — matches 'end' when not at a word boundary.
      alternations:
        short: Alternations
        description: 'Alternations: Match one of several alternatives using the | operator.'
        examples:
          0:
            pattern: cat|dog
            test: I have a cat
            result: match
            options: ''
            substitution: ''
            description: 'cat|dog — matches one of the alternatives in the pattern.'
          1:
            pattern: cat|dog
            test: I have a dog
            result: match
            options: ''
            substitution: ''
            description: 'cat|dog — matches one of the alternatives in the pattern.'
          2:
            pattern: cat|dog
            test: I have a bird
            result: no-match
            options: ''
            substitution: ''
            description: 'cat|dog — matches one of the alternatives in the pattern.'
          3:
            pattern: red|green|blue
            test: green apple
            result: match
            options: ''
            substitution: ''
            description: 'red|green|blue — matches one of the alternatives in the pattern.'
          4:
            pattern: red|green|blue
            test: yellow banana
            result: no-match
            options: ''
            substitution: ''
            description: 'red|green|blue — matches one of the alternatives in the pattern.'
      anchors:
        short: Anchors
        description: "Anchors: Match positions in the string using anchors like ^, $, A, \b."
        examples:
          0:
            pattern: ^start
            test: start here
            result: match
            options: ''
            substitution: ''
            description: ^start — matches at the start of the string.
          1:
            pattern: ^start
            test: this is start
            result: no-match
            options: ''
            substitution: ''
            description: ^start — not matching at the start of the string.
          2:
            pattern: end$
            test: This is the end
            result: match
            options: ''
            substitution: ''
            description: end$ — matches at the end of the string.
          3:
            pattern: end$
            test: end somewhere
            result: no-match
            options: ''
            substitution: ''
            description: end$ — not matching at the end of the string.
          4:
            pattern: \bword\b
            test: The word is here
            result: match
            options: ''
            substitution: ''
            description: \bword\b — matches the whole word 'word' using word boundaries.
          5:
            pattern: \bhello\b
            test: helloworld
            result: no-match
            options: ''
            substitution: ''
            description: \bhello\b — matches the whole word 'hello' using word boundaries.
          6:
            pattern: \Aabc
            test: abc anywhere
            result: match
            options: ''
            substitution: ''
            description: \Aabc — matches at the start of the string.
          7:
            pattern: \Aabc
            test: this abc anywhere
            result: no-match
            options: ''
            substitution: ''
            description: \Aabc — not matching at the start of the string.
          8:
            pattern: xyz\b
            test: xyzxyz
            result: match
            options: ''
            substitution: ''
            description: xyz\b — matches 'xyz' at a word boundary.
          9:
            pattern: xyz\b
            test: xyz is here
            result: match
            options: ''
            substitution: ''
            description: xyz\b — matches 'xyz' at a word boundary.
          10:
            pattern: start\Z
            test: start
            result: match
            options: ''
            substitution: ''
            description: start\Z — matches at the end of the string.
          11:
            pattern: start\Z
            test: test start
            result: match
            options: ''
            substitution: ''
            description: start\Z — matches at the end of the string.
      character-classes:
        short: Character Classes
        description: 'Character Classes: Match specific sets of characters inside square brackets.'
        examples:
          0:
            pattern: "[abc]"
            test: a1bc
            result: match
            options: ''
            substitution: ''
            description: "[abc] — matches any single character from the character class."
          1:
            pattern: "[^abc]"
            test: a1bc
            result: match
            options: ''
            substitution: ''
            description: "[^abc] — matches any single character not in the class."
          2:
            pattern: "[0-9]"
            test: abc123
            result: match
            options: ''
            substitution: ''
            description: "[0-9] — matches any single character from the character class."
          3:
            pattern: "[a-z]"
            test: abc123
            result: match
            options: ''
            substitution: ''
            description: "[a-z] — matches any single character from the character class."
          4:
            pattern: "[A-Z]"
            test: abc123XYZ
            result: match
            options: ''
            substitution: ''
            description: "[A-Z] — matches any single character from the character class."
          5:
            pattern: "[^\\\\]"
            test: hello\world
            result: match
            options: ''
            substitution: ''
            description: "[^\\\\] — matches any single character not in the class."
          6:
            pattern: "[a-d&&aeiou]"
            test: abcd123
            result: match
            options: ''
            substitution: ''
            description: "[a-d&&aeiou] — matches any single character from the character class."
          7:
            pattern: "[a-d&&[^aeiou]]"
            test: abcd123
            result: match
            options: ''
            substitution: ''
            description: "[a-d&&[^aeiou]] — matches any single character from the class after negation."
          8:
            pattern: "[a=e=b]"
            test: a
            result: match
            options: ''
            substitution: ''
            description: "[a=e=b] — matches any single character from the character class."
      character-types:
        short: Character Types
        description: 'Digits, whitespace, word/non-word, and related types.'
        examples:
          0:
            pattern: "\\d"
            test: hello123
            result: match
            options: ''
            substitution: ''
            description: "\\d: matches a digit."
          1:
            pattern: "\\d"
            test: helloworld
            result: no-match
            options: ''
            substitution: ''
            description: "\\d: no match when no digit present."
          2:
            pattern: "\\H"
            test: hello world
            result: match
            options: ''
            substitution: ''
            description: "\\H: matches non-horizontal whitespace (engine-specific)."
          3:
            pattern: "\\s"
            test: hello world
            result: match
            options: ''
            substitution: ''
            description: "\\s: matches whitespace."
          4:
            pattern: "\\S"
            test: hello world
            result: match
            options: ''
            substitution: ''
            description: "\\S: matches non-whitespace."
          5:
            pattern: "\\w"
            test: helloworld123
            result: match
            options: ''
            substitution: ''
            description: "\\w: matches word characters (letters/digits/_)."
          6:
            pattern: "\\w"
            test: hello@world
            result: match
            options: ''
            substitution: ''
            description: "\\w: matches word characters."
          7:
            pattern: "\\W"
            test: hello@world
            result: match
            options: ''
            substitution: ''
            description: "\\W: matches non-word characters."
          8:
            pattern: "\\W"
            test: hello@world
            result: no-match
            options: ''
            substitution: ''
            description: "\\W: no match when none present."
      cluster-types:
        short: Cluster Types
        description: 'Match newline clusters (\R) and grapheme clusters (\X).' 
        examples:
          0:
            pattern: "\\R"
            test: |-
              abc
              123
            result: match
            options: ''
            substitution: ''
            description: "\\R: matches newline cluster."
          1:
            pattern: "\\R"
            test: "hello\rworld"
            result: match
            options: ''
            substitution: ''
            description: "\\R: matches newline cluster."
          2:
            pattern: "\\X"
            test: "\U0001F44B"
            result: match
            options: ''
            substitution: ''
            description: "\\X: matches one grapheme cluster (e.g., emoji)."
          3:
            pattern: "\\X"
            test: "abc\U0001F44B123"
            result: match
            options: ''
            substitution: ''
            description: "\\X: matches grapheme cluster within text."
          4:
            pattern: "\\X"
            test: abć
            result: match
            options: ''
            substitution: ''
            description: "\\X: matches composed character (grapheme)."
      conditional-expressions:
        short: Conditional Expressions
        description: 'Conditional patterns: branch based on capture or condition.'
        examples:
          0:
            pattern: "(?<A>a)(?(<A>)T|F)"
            test: aT
            result: match
            options: ''
            substitution: ''
            description: "Branch when group A matched: choose T or F."
          1:
            pattern: "(?<A>a)(?(<A>)T|)"
            test: aT
            result: match
            options: ''
            substitution: ''
            description: "Branch based on named group presence."
          2:
            pattern: "(a)(?(001)T)"
            test: aT
            result: match
            options: ''
            substitution: ''
            description: "Numeric condition: branch when group 001 matched."
          3:
            pattern: "\\A(?:(set)|(print))\\s+(\\w+)(?(1)=(\\d+))\\z"
            test: set x=32
            result: match
            options: ''
            substitution: ''
            description: "Conditional: if 'set' matched expect digits after '='."
          4:
            pattern: "\\A(?:(set)|(print))\\s+(\\w+)(?(1)=(\\d+))\\z"
            test: print x
            result: match
            options: ''
            substitution: ''
            description: "Conditional example: different branch for 'print'."
          5:
            pattern: "\\A(?:(set)|(print))\\s+(\\w+)(?(1)=(\\d+))\\z"
            test: set y
            result: no-match
            options: ''
            substitution: ''
            description: "No-match when required branch condition not met."
      escape-sequences:
        short: Escape Sequences
        description: 'Escapes: \t, \n, \d and other escape sequences.'
        examples:
          0:
            pattern: "\\t"
            test: "a\t"
            result: match
            options: ''
            substitution: ''
            description: "\\t: matches a tab character."
          1:
            pattern: "\\n"
            test: 'a

              '
            result: match
            options: ''
            substitution: ''
            description: "\\n: matches a newline."
          2:
            pattern: "\\d"
            test: '5'
            result: match
            options: ''
            substitution: ''
            description: "\\d: matches a digit."
          3:
            pattern: "\\d"
            test: a
            result: no-match
            options: ''
            substitution: ''
            description: "\\d: no match when no digit present."
          4:
            pattern: "\\s"
            test: 'a '
            result: match
            options: ''
            substitution: ''
            description: "\\s — matches pattern '\\s'."
          5:
            pattern: "\\S"
            test: a
            result: match
            options: ''
            substitution: ''
            description: "\\S — Matches a non-whitespace character."
          6:
            pattern: "\\w"
            test: a
            result: match
            options: ''
            substitution: ''
            description: "\\w — matches pattern '\\w'."
          7:
            pattern: "\\W"
            test: "$"
            result: match
            options: ''
            substitution: ''
            description: "\\W — Matches a non-word character."
          8:
            pattern: "\\b"
            test: word
            result: match
            options: ''
            substitution: ''
            description: "\\b — Word boundary anchor."
          9:
            pattern: "\\B"
            test: word
            result: no-match
            options: ''
            substitution: ''
            description: "\\B — Non-word-boundary anchor."
          10:
            pattern: "\\f"
            test: "a\f"
            result: match
            options: ''
            substitution: ''
            description: "\\f — Matches a form-feed character."
          11:
            pattern: "\\r"
            test: "a\r"
            result: match
            options: ''
            substitution: ''
            description: "\\r — Matches a carriage-return character."
          12:
            pattern: "\\0"
            test: "a\0"
            result: match
            options: ''
            substitution: ''
            description: "\\0 — matches repeated text using back-references."
          13:
            pattern: "\\x41"
            test: A
            result: match
            options: ''
            substitution: ''
            description: "\\x41 — Matches the character 'A' (hex 41)."
          14:
            pattern: "\\\\+"
            test: a\
            result: match
            options: ''
            substitution: ''
            description: "\\\\+ — Matches one-or-more backslashes."
          15:
            pattern: "\\?"
            test: "?"
            result: match
            options: ''
            substitution: ''
            description: "\\? — Matches a literal question mark."
      free-space:
        short: Free Space
        description: 'Free Space: Match whitespace and comments using the x modifier.'
        examples:
          0:
            pattern: "a  # comment \nb"
            test: ab
            result: match
            options: x
            substitution: ''
            description: "Free-spacing mode: comments ignored; matches 'ab'."
          1:
            pattern: |2-
                a  # word
                b
            test: ab
            result: match
            options: x
            substitution: ''
            description: |2-
                a  # word
                b — [meta: concatenation] matches the exact sequence '  a  # word
                b'.
          2:
            pattern: "  a #word \nb"
            test: ab
            result: match
            options: x
            substitution: ''
            description: "Free-spacing mode: comments ignored; matches 'ab'."
          3:
            pattern: |2-
                 a   # starting
                 b
            test: ab
            result: match
            options: x
            substitution: ''
            description: |2-
                 a   # starting
                 b — [meta: concatenation] matches the exact sequence '   a   # starting
                 b'.
      group-assertions:
        short: Group Assertions
        description: 'Lookahead and lookbehind assertions (zero-width).'
        examples:
          0:
            pattern: "(?=abc)"
            test: abc
            result: match
            options: ''
            substitution: ''
            description: "(?=...): positive lookahead — assert 'abc' ahead."
          1:
            pattern: "(?=\\w+)"
            test: hello world
            result: match
            options: ''
            substitution: ''
            description: "(?=\\w+): lookahead asserting word chars ahead."
          2:
            pattern: "(?!abc)"
            test: xyz
            result: match
            options: ''
            substitution: ''
            description: "(?!...): negative lookahead — assert 'abc' not ahead."
          3:
            pattern: "(?<=abc)"
            test: abcxyz
            result: match
            options: ''
            substitution: ''
            description: "(?<=...): positive lookbehind — assert 'abc' behind."
          4:
            pattern: "(?<=\\d{3})"
            test: 123abc
            result: match
            options: ''
            substitution: ''
            description: "(?<=\\d{3}): lookbehind for 3 digits."
          5:
            pattern: "(?<=\\b)"
            test: hello
            result: match
            options: ''
            substitution: ''
            description: "(?<=\\b): lookbehind at a word boundary."
          6:
            pattern: "(?<!abc)"
            test: xyzabc
            result: match
            options: ''
            substitution: ''
            description: "(?<!...): negative lookbehind — assert 'abc' not behind."
          7:
            pattern: "(?<!\\d)"
            test: abc123
            result: match
            options: ''
            substitution: ''
            description: "(?<!\\d): lookbehind asserting non-digit behind."
          8:
            pattern: "(?<!\\d{2})"
            test: abc123
            result: match
            options: ''
            substitution: ''
            description: "(?<!\\d{2}): negative lookbehind for 2 digits."
      group-atomic:
        short: Group Atomic
        description: 'Atomic groups (?>...) prevent backtracking inside the group.'
        examples:
          0:
            pattern: a(bc|b)c
            test: abc
            result: match
            options: ''
            substitution: ''
            description: "Alternation example: chooses appropriate branch."
          1:
            pattern: a(?>bc|b)c
            test: abc
            result: no-match
            options: ''
            substitution: ''
            description: "Atomic group prevents backtracking between alternatives."
          2:
            pattern: "(\\w+)\\d{3}"
            test: user123
            result: match
            options: ''
            substitution: ''
            description: "Capture then digits: captures word then 3 digits."
          3:
            pattern: "(?>\\w+)\\d{3}"
            test: user123
            result: no-match
            options: ''
            substitution: ''
            description: "Atomic capture prevents digits match after greedy consumption."
          4:
            pattern: Start(A+|A*B)End
            test: StartABEnd
            result: match
            options: ''
            substitution: ''
            description: "Alternation with repetition example."
          5:
            pattern: Start(?>A+|A*B)End
            test: StartABEnd
            result: no-match
            options: ''
            substitution: ''
            description: "Atomic alternation changes matching behavior."
      group-absence:
        short: Group Absence
        description: 'Absence operator (?~): match substrings that do not contain a pattern.'
        examples:
          0:
            pattern: "(?~abc)"
            test: ab
            result: match
            options: ''
            substitution: ''
            description: "Matches when 'abc' is not present."
          1:
            pattern: "(?~abc)"
            test: aab
            result: match
            options: ''
            substitution: ''
            description: "Matches when 'abc' absent."
          2:
            pattern: "(?~abc)"
            test: abb
            result: match
            options: ''
            substitution: ''
            description: "Matches when 'abc' absent."
          3:
            pattern: "(?~abc)"
            test: abc
            result: match
            options: ''
            substitution: ''
            description: "Matches when 'abc' absent even if exact substring exists elsewhere."
          4:
            pattern: "^(?~abc)$"
            test: abc
            result: no-match
            options: ''
            substitution: ''
            description: "Full-string absence: no 'abc' allowed."
          5:
            pattern: "(?~abc)"
            test: aabc
            result: match
            options: ''
            substitution: ''
            description: "Matches when 'abc' not present."
          6:
            pattern: "(?~abc)"
            test: ccabcdd
            result: match
            options: ''
            substitution: ''
            description: "Matches when 'abc' not present."
          7:
            pattern: "/\\*(?~\\*/)*\\*/"
            test: "/**/"
            result: match
            options: ''
            substitution: ''
            description: "Matches C-style empty comment."
          8:
            pattern: "/\\*(?~\\*/)*\\*/"
            test: "/* foo bar */"
            result: match
            options: ''
            substitution: ''
            description: "Matches C-style comment with content."
      group-back-references:
        short: Group Back-references
        description: 'Back-references: match previously captured text by number or name.'
        examples:
          0:
            pattern: "(\\d)\\1"
            test: '11'
            result: match
            options: ''
            substitution: ''
            description: "Back-reference: same digit repeated."
          1:
            pattern: "(?<word>\\w+)\\s\\k<word>"
            test: hello hello
            result: match
            options: ''
            substitution: ''
            description: "Named back-reference: repeats the captured word."
          2:
            pattern: "(\\d+)\\k<1>"
            test: '123123'
            result: match
            options: ''
            substitution: ''
            description: "Numeric back-reference: repeats captured digits."
          3:
            pattern: "(\\w+)\\s\\1"
            test: hello hello
            result: match
            options: ''
            substitution: ''
            description: "Back-reference by number: repeats the first group."
          4:
            pattern: "(\\d{3})-(\\d{2})-(\\d{4})\\k<1>"
            test: 123-45-6789123
            result: match
            options: ''
            substitution: ''
            description: "Repeats first group after SSN-like pattern."
          5:
            pattern: "(\\w+)-(\\w+)\\k<2>"
            test: apple-orangeorange
            result: match
            options: ''
            substitution: ''
            description: "Repeats second group after hyphen."
          6:
            pattern: "(\\d{3})-(\\d{2})-(\\d{4})\\k<2>"
            test: 123-45-678945
            result: match
            options: ''
            substitution: ''
            description: "Repeats second group (numeric back-ref)."
          7:
            pattern: "(\\d+)\\1"
            test: '12345'
            result: no-match
            options: ''
            substitution: ''
            description: "No-match when repetition not present."
          8:
            pattern: "(.)(.)\\k<-2>\\k<-1>"
            test: xyzyz
            result: match
            options: ''
            substitution: ''
            description: "Relative back-references example."
      group-capturing:
        short: Group Capturing
        description: 'Capture groups: numbered or named groups to extract submatches.'
        examples:
          0:
            pattern: "(abc)"
            test: abc
            result: match
            options: ''
            substitution: ''
            description: "Captures 'abc' in group 1."
          1:
            pattern: "(\\d{2})-(\\d{2})-(\\d{4})"
            test: 12-34-5678
            result: match
            options: ''
            substitution: ''
            description: "Captures date parts as separate groups."
          2:
            pattern: "(\\w+)@(\\w+\\.\\w+)"
            test: alice@example.com
            result: match
            options: ''
            substitution: ''
            description: "Captures username and domain from email."
          3:
            pattern: "(\\d+)-(\\d+)"
            test: 123-456
            result: match
            options: ''
            substitution: ''
            description: "Captures two number groups separated by hyphen."
          4:
            pattern: "(\\w{3})-(\\w{3})"
            test: abc-def
            result: match
            options: ''
            substitution: ''
            description: "Captures two 3-letter groups."
          5:
            pattern: "(\\d{4})(\\d{2})(\\d{2})"
            test: '20211225'
            result: match
            options: ''
            substitution: ''
            description: "Captures YYYY MM DD as separate groups."
          6:
            pattern: "(\\w+)\\s(\\w+)"
            test: hello world
            result: match
            options: ''
            substitution: ''
            description: "Captures two words separated by whitespace."
          7:
            pattern: "(\\w+)\\s+\\1"
            test: hello hello
            result: match
            options: ''
            substitution: ''
            description: "Captures a word then matches same word again using back-ref."
      group-comments:
        short: Group Comments
        description: 'Include comments in regex with (?# ... ).'
        examples:
          0:
            pattern: "(?# This is a comment)abc"
            test: abc
            result: match
            options: ''
            substitution: ''
            description: "Matches 'abc' (comment ignored)."
          1:
            pattern: a(?# matches 'a')b
            test: ab
            result: match
            options: ''
            substitution: ''
            description: "Matches 'ab' (comment ignored)."
          2:
            pattern: "(?#Start of string)^abc(?#End of string)$"
            test: abc
            result: match
            options: ''
            substitution: ''
            description: "Matches 'abc' anchored to start and end (comments ignored)."
          3:
            pattern: "(?# a comment in the middle )ab(?# another comment)"
            test: ab
            result: match
            options: ''
            substitution: ''
            description: "Matches 'ab' with inline comments ignored."
          4:
            pattern: "(?# This pattern matches digits )\\d+"
            test: '12345'
            result: match
            options: ''
            substitution: ''
            description: "Matches one or more digits (comments ignored)."
          5:
            pattern: "(?# matches a space )\\s"
            test: " "
            result: match
            options: ''
            substitution: ''
            description: "Matches a whitespace character (comments ignored)."
          6:
            pattern: "(?# comment before and after )\\w{3,}"
            test: word
            result: match
            options: ''
            substitution: ''
            description: "Matches three-or-more word characters (comments ignored)."
      group-named:
        short: Group Named
        description: 'Capture groups with a name for reference.'
        examples:
          0:
            pattern: "(?<name>Alice)"
            test: Alice
            result: match
            options: ''
            substitution: ''
            description: "Captures 'Alice' into named group 'name'."
          1:
            pattern: "(?'name'Alice)"
            test: Alice
            result: match
            options: ''
            substitution: ''
            description: "Captures 'Alice' into named group 'name'."
          2:
            pattern: "(?P<name>Alice)"
            test: Alice
            result: no-match
            options: ''
            substitution: ''
            description: "Python-style named capture; may not match in all engines."
          3:
            pattern: "(?<year>\\d{4})-(?'month'\\d{2})-(?'day'\\d{2})"
            test: '2023-07-25'
            result: match
            options: ''
            substitution: ''
            description: "Captures year, month, day into named groups."
          4:
            pattern: "(?<hour>\\d{2}):(?'minute'\\d{2})"
            test: '14:30'
            result: match
            options: ''
            substitution: ''
            description: "Captures hour and minute into named groups."
          5:
            pattern: "(?<user>\\w+)@(?<domain>\\w+\\.\\w+)"
            test: alice@example.com
            result: match
            options: ''
            substitution: ''
            description: "Captures user and domain into named groups for an email-like string."
          6:
            pattern: "\\$(?<dollars>\\d+)\\.(?<cents>\\d+)"
            test: "$3.67"
            result: match
            options: ''
            substitution: ''
            description: "Captures dollars and cents into named groups."
          7:
            pattern: "(?<vowel>[aeiou]).\\k<vowel>.\\k<vowel>"
            test: ototomy
            result: match
            options: ''
            substitution: ''
            description: "Uses named back-reference to repeat a previously captured vowel."
          8:
            pattern: "(?<name>\\w+)(\\d{3})"
            test: user123
            result: match
            options: ''
            substitution: ''
            description: "Captures a name and following three digits (name is named)."
      group-options:
        short: Group Options
        description: 'Inline options like (?i), (?m), (?x) that change matching behavior.'
        examples:
          0:
            pattern: "(?i)abc"
            test: ABC
            result: match
            options: ''
            substitution: ''
            description: "Case-insensitive match for 'abc'."
          1:
            pattern: "(?m)^abc"
            test: |-
              abc
              abc
            result: match
            options: ''
            substitution: ''
            description: "Multiline: ^ matches a line start; matches 'abc'."
          2:
            pattern: |-
              (?x) a # space is ignored
              b
            test: ab
            result: match
            options: ''
            substitution: ''
            description: |- 
              Free-spacing mode: spaces/comments ignored; matches 'ab'.
          3:
            pattern: "(?i)hello(?-i)world"
            test: HELLOworld
            result: match
            options: ''
            substitution: ''
            description: "Case-insensitive for 'hello' only; matches 'HELLOworld'."
          4:
            pattern: "(?i)(abc)(?-i)def"
            test: ABCdef
            result: match
            options: ''
            substitution: ''
            description: "Turns on case-insensitive for group then off; matches 'ABCdef'."
          5:
            pattern: "(?m)\\bstart\\b"
            test: |-
              start
              start
            result: match
            options: ''
            substitution: ''
            description: "Multiline word-boundary match for 'start'."
          6:
            pattern: |-
              (?x) a # space is ignored
              c
            test: ac
            result: match
            options: ''
            substitution: ''
            description: |- 
              Free-spacing mode: spaces/comments ignored; matches 'ac'.
      group-passive:
        short: Group Passive
        description: 'Non-capturing groups (?:...) that do not create capture slots.'
        examples:
          0:
            pattern: "(?:abc)"
            test: abc
            result: match
            options: ''
            substitution: ''
            description: "Non-capturing group matching 'abc'."
          1:
            pattern: "(?:\\d{2})-(?:\\d{2})-(?:\\d{4})"
            test: 12-34-5678
            result: match
            options: ''
            substitution: ''
            description: "Non-capturing groups used for a date-like pattern."
          2:
            pattern: "(?:\\w+)@(\\w+\\.\\w+)"
            test: alice@example.com
            result: match
            options: ''
            substitution: ''
            description: "Local part non-capturing; domain captured by a regular group."
      group-subexpression-calls:
        short: Group Subexp. Calls
        description: 'Call a previous group by index or name (back-reference/subexp call).'
        examples:
          0:
            pattern: "(abc)\\g<1>"
            test: abcabc
            result: match
            options: ''
            substitution: ''
            description: "Repeats the first group; matches 'abcabc'."
          1:
            pattern: "(?<name>hello)\\g<name>"
            test: hellohello
            result: match
            options: ''
            substitution: ''
            description: "Repeats the named group 'name' to match 'hellohello'."
          2:
            pattern: "(abc)(def)\\g<1>\\g<2>"
            test: abcdefabcdef
            result: match
            options: ''
            substitution: ''
            description: "Repeats group 1 and 2 to form 'abcdefabcdef'."
      keep:
        short: Keep
        description: 'Use \K to reset the match start; text before \K is excluded from the final match.'
        examples:
          0:
            pattern: ab\Kcd
            test: abcdef
            result: match
            options: ''
            substitution: ''
            description: "Keeps 'ab' then matches 'cd'; final match is 'cd'."
          1:
            pattern: a\Kb
            test: abc
            result: match
            options: ''
            substitution: ''
            description: "Keeps 'a' then matches 'b'; final match is 'b'."
          2:
            pattern: foo\Kbar
            test: foobar
            result: match
            options: ''
            substitution: ''
            description: "Keeps 'foo' then matches 'bar'; final match is 'bar'."
          3:
            pattern: xyz\Kabc
            test: xyzabc
            result: match
            options: ''
            substitution: ''
            description: "Keeps 'xyz' then matches 'abc'; final match is 'abc'."
          4:
            pattern: start\Kend
            test: startend
            result: match
            options: ''
            substitution: ''
            description: "Keeps 'start' then matches 'end'; final match is 'end'."
          5:
            pattern: one\Ktwo
            test: one two
            result: match
            options: ''
            substitution: ''
            description: "Keeps 'one' then matches 'two'; final match is 'two'."
          6:
            pattern: aaa\Kbbb
            test: aaabbb
            result: match
            options: ''
            substitution: ''
            description: "Keeps 'aaa' then matches 'bbb'; final match is 'bbb'."
          7:
            pattern: 1\K2
            test: '12'
            result: match
            options: ''
            substitution: ''
            description: "Keeps '1' then matches '2'; final match is '2'."
          8:
            pattern: abc\Kxyz
            test: abcxyz
            result: match
            options: ''
            substitution: ''
            description: "Keeps 'abc' then matches 'xyz'; final match is 'xyz'."
          9:
            pattern: quick\Kbrown
            test: quickbrown
            result: match
            options: ''
            substitution: ''
            description: "Keeps 'quick' then matches 'brown'; final match is 'brown'."
      literals:
        short: Literals
        description: 'Match literal character sequences (including Unicode).'
        examples:
          0:
            pattern: Ruby
            test: Ruby
            result: match
            options: ''
            substitution: ''
            description: "Matches the literal 'Ruby'."
          1:
            pattern: apple
            test: apple pie
            result: match
            options: ''
            substitution: ''
            description: "Matches the literal 'apple'."
          2:
            pattern: dog
            test: doghouse
            result: match
            options: ''
            substitution: ''
            description: "Matches the literal 'dog'."
          3:
            pattern: '123'
            test: '1234'
            result: match
            options: ''
            substitution: ''
            description: "Matches the literal '123'."
          4:
            pattern: abc
            test: abcdef
            result: match
            options: ''
            substitution: ''
            description: "Matches the literal 'abc'."
          5:
            pattern: "\U0001F603"
            test: "I am happy \U0001F603"
            result: match
            options: ''
            substitution: ''
            description: "Matches the Unicode emoji U+1F603."
          6:
            pattern: ルビー
            test: 私はルビーが好きです
            result: match
            options: ''
            substitution: ''
            description: "Matches the Japanese literal 'ルビー'."
          7:
            pattern: روبي
            test: اسمي روبي
            result: match
            options: ''
            substitution: ''
            description: "Matches the Arabic literal 'روبي'."
          8:
            pattern: apple
            test: applepie
            result: no-match
            options: ''
            substitution: ''
            description: "Matches 'apple' exactly (no trailing characters)."
          9:
            pattern: dog
            test: god
            result: no-match
            options: ''
            substitution: ''
            description: "Does not match; 'dog' != 'god'."
          10:
            pattern: "\U0001F30D"
            test: "world \U0001F30D"
            result: match
            options: ''
            substitution: ''
            description: "Matches the Unicode emoji U+1F30D."
      posix-classes:
        short: POSIX Classes
        description: 'POSIX character classes like [:alpha:], [:digit:] and their negations.'
        examples:
          0:
            pattern: "[[:alpha:]]+"
            test: abc123XYZ
            result: match
            options: ''
            substitution: ''
            description: "Matches one-or-more alphabetic characters."
          1:
            pattern: "[[:^alpha:]]+"
            test: abc123XYZ
            result: match
            options: ''
            substitution: ''
            description: "Matches non-alphabetic characters (one-or-more)."
          2:
            pattern: "[[:digit:]]+"
            test: abc123.45def
            result: match
            options: ''
            substitution: ''
            description: "Matches one-or-more digits."
          3:
            pattern: "[[:punct:]]+"
            test: hello!?
            result: match
            options: ''
            substitution: ''
            description: "Matches one-or-more punctuation characters."
          4:
            pattern: "[[:space:]]+"
            test: "a b\tc\n"
            result: match
            options: ''
            substitution: ''
            description: "Matches one-or-more whitespace characters."
          5:
            pattern: "[[:lower:]]+"
            test: AbC
            result: match
            options: ''
            substitution: ''
            description: "Matches one-or-more lowercase letters."
          6:
            pattern: "[[:upper:]]+"
            test: AbC
            result: match
            options: ''
            substitution: ''
            description: "Matches one-or-more uppercase letters."
      quantifiers-greedy:
        short: Quantifiers Greedy
        description: 'Greedy quantifiers: Match as many times as possible.'
        examples:
          0:
            pattern: a*
            test: abc123!
            result: match
            options: ''
            substitution: ''
            description: "a* — Zero or more 'a'."
          1:
            pattern: a*
            test: aaaabc123!
            result: match
            options: ''
            substitution: ''
            description: "a* — Zero or more 'a'."
          2:
            pattern: a+
            test: abc123!
            result: match
            options: ''
            substitution: ''
            description: "a+ — One or more 'a'."
          3:
            pattern: a{2}
            test: abc123!
            result: no-match
            options: ''
            substitution: ''
            description: "a{2} — Exactly two 'a'."
          4:
            pattern: "(abc)*"
            test: abc123!
            result: match
            options: ''
            substitution: ''
            description: "(abc)* — Zero or more repetitions of 'abc'."
          5:
            pattern: "(abc)+"
            test: abc123!
            result: match
            options: ''
            substitution: ''
            description: "(abc)+ — One or more repetitions of 'abc'."
          6:
            pattern: "(abc)?"
            test: abc123!
            result: match
            options: ''
            substitution: ''
            description: "(abc)? — Zero or one 'abc'."
          7:
            pattern: "(abc){2}"
            test: abcabc123!
            result: match
            options: ''
            substitution: ''
            description: "(abc){2} — Exactly two repetitions of 'abc'."
          8:
            pattern: "(abc){2,3}"
            test: abcabc123!
            result: match
            options: ''
            substitution: ''
            description: "(abc){2,3} — Two to three repetitions of 'abc'."
          9:
            pattern: "(abc){2,3}"
            test: abcabcabc123!
            result: match
            options: ''
            substitution: ''
            description: "(abc){2,3} — Two to three repetitions of 'abc'."
      quantifiers-reluctant-lazy:
        short: Quantifiers Reluctant (Lazy)
        description: 'Reluctant (lazy) quantifiers: match as few times as possible. Note: some exact-count lazy forms are unnecessary or unsupported.'
        examples:
          0:
            pattern: a*?
            test: abc123!
            result: match
            options: ''
            substitution: ''
            description: "a*? — Lazy: zero-or-more 'a' (minimal match)."
          1:
            pattern: a*?
            test: aaaabc123!
            result: match
            options: ''
            substitution: ''
            description: "a*? — Lazy: zero-or-more 'a' (minimal match)."
          2:
            pattern: a+?
            test: abc123!
            result: match
            options: ''
            substitution: ''
            description: "a+? — Lazy: one-or-more 'a' (minimal match)."
          3:
            pattern: a{2}?
            test: abc123!
            result: no-match
            options: ''
            substitution: ''
            description: "a{2}? — Lazy: exactly two 'a' (redundant in most engines)."
          4:
            pattern: "(abc)*?"
            test: abc123!
            result: match
            options: ''
            substitution: ''
            description: "(abc)*? — Lazy: zero-or-more 'abc' (minimal)."
          5:
            pattern: "(abc)+?"
            test: abc123!
            result: match
            options: ''
            substitution: ''
            description: "(abc)+? — Lazy: one-or-more 'abc' (minimal)."
          6:
            pattern: "(abc)?"
            test: abc123!
            result: match
            options: ''
            substitution: ''
            description: "(abc)? — Zero or one 'abc'."
          7:
            pattern: "(abc){2}?"
            test: abcabc123!
            result: match
            options: ''
            substitution: ''
            description: "(abc){2}? — Lazy: two repetitions of 'abc'."
          8:
            pattern: "(abc){2,3}?"
            test: abcabc123!
            result: match
            options: ''
            substitution: ''
            description: "(abc){2,3}? — Lazy: two-to-three 'abc' repetitions."
          9:
            pattern: "(abc){2,3}?"
            test: abcabcabc123!
            result: match
            options: ''
            substitution: ''
            description: "(abc){2,3}? — Lazy: two-to-three 'abc' repetitions."
      quantifiers-possessive:
        short: Quantifiers Possessive
        description: 'Possessive quantifiers: match without backtracking when supported by the engine.'
        examples:
          0:
            pattern: a*+
            test: abc123!
            result: match
            options: ''
            substitution: ''
            description: "a*+ — Possessive: zero-or-more 'a' (no backtracking)."
          1:
            pattern: a*+
            test: aaaabc123!
            result: match
            options: ''
            substitution: ''
            description: "a*+ — Possessive: zero-or-more 'a' (no backtracking)."
          2:
            pattern: a++
            test: abc123!
            result: match
            options: ''
            substitution: ''
            description: "a++ — Possessive: one-or-more 'a' (no backtracking)."
          3:
            pattern: "(abc)*+"
            test: abc123!
            result: match
            options: ''
            substitution: ''
            description: "(abc)*+ — Possessive: zero-or-more 'abc' (no backtracking)."
          4:
            pattern: "(abc)++"
            test: abc123!
            result: match
            options: ''
            substitution: ''
            description: "(abc)++ — Possessive: one-or-more 'abc' (no backtracking)."
          5:
            pattern: "(abc)?+"
            test: abc123!
            result: match
            options: ''
            substitution: ''
            description: "(abc)?+ — Possessive: zero-or-one 'abc' (no backtracking)."
      string-escapes:
        short: String Escapes
        description: 'String Escapes: Match special characters using escape sequences like d, w,  , etc.'
        examples:
          0:
            pattern: "\\d"
            test: 123abc
            result: match
            options: ''
            substitution: ''
            description: "\\d — matches pattern '\\d'."
          1:
            pattern: "\\d"
            test: abc123
            result: no-match
            options: ''
            substitution: ''
            description: "\\d — matches pattern '\\d'."
          2:
            pattern: "\\w"
            test: abc123
            result: match
            options: ''
            substitution: ''
            description: "\\w — matches pattern '\\w'."
          3:
            pattern: "\\w"
            test: 123!@#
            result: match
            options: ''
            substitution: ''
            description: "\\w — matches pattern '\\w'."
          4:
            pattern: "\\W"
            test: "!@#"
            result: match
            options: ''
            substitution: ''
            description: "\\W — Matches a non-word character."
          5:
            pattern: "\\s"
            test: abc def
            result: match
            options: ''
            substitution: ''
            description: "\\s — matches pattern '\\s'."
          6:
            pattern: "\\S"
            test: abc def
            result: match
            options: ''
            substitution: ''
            description: "\\S — Matches a non-whitespace character."
          7:
            pattern: "\\b"
            test: hello world
            result: match
            options: ''
            substitution: ''
            description: "\\b — Word boundary anchor."
          8:
            pattern: "\\B"
            test: abc123
            result: match
            options: ''
            substitution: ''
            description: "\\B — Non-word-boundary anchor."
          9:
            pattern: "\\x20"
            test: abc 123
            result: match
            options: ''
            substitution: ''
            description: "\\x20 — Matches a space character (hex 20)."
          10:
            pattern: "\\u{1F60D}"
            test: "I love emojis \U0001F60D"
            result: match
            options: ''
            substitution: ''
            description: "\\u{1F60D} — Matches the emoji U+1F60D."
      unicode-age:
        short: Unicode Age
        description: Match characters by Unicode version (Age). Supports \p{Age}, \P{Age}, and caret negation.
        examples:
          0:
            pattern: "\\p{Age=5.2}+"
            test: "\U0001F929☆あ"
            result: match
            options: ''
            substitution: ''
            description: "\\p{Age=5.2}+ — Matches characters added in Unicode Age 5.2."
          1:
            pattern: "\\P{Age=6.1}+"
            test: "Aあ\U0001F914"
            result: match
            options: ''
            substitution: ''
            description: "\\P{Age=6.1}+ — Matches characters not in Unicode Age 6.1."
          2:
            pattern: "\\p{Age=3.0}+"
            test: "¡¿D"
            result: match
            options: ''
            substitution: ''
            description: "\\p{Age=3.0}+ — Matches characters added in Unicode Age 3.0."
          3:
            pattern: "\\P{Age=5.2}+"
            test: "ABC\U0001F929"
            result: match
            options: ''
            substitution: ''
            description: "\\P{Age=5.2}+ — Matches characters not in Unicode Age 5.2."
          4:
            pattern: "\\p{Age=7.0}+"
            test: "\U0001D11EC"
            result: match
            options: ''
            substitution: ''
            description: "\\p{Age=7.0}+ — Matches characters added in Unicode Age 7.0."
          5:
            pattern: "\\P{Age=8.0}+"
            test: "abc\U0001F9ED"
            result: match
            options: ''
            substitution: ''
            description: "\\P{Age=8.0}+ — Matches characters not in Unicode Age 8.0."
      unicode-blocks:
        short: Unicode Blocks
        description: Match by Unicode block. Use \p{In…}, \P{In…}, or caret negation.
        examples:
          0:
            pattern: "\\p{InKatakana}+"
            test: カタカナあA
            result: match
            options: ''
            substitution: ''
            description: "\\p{InKatakana}+ — Matches characters in the Katakana block."
          1:
            pattern: "\\p{InArmenian}+"
            test: ԱԲԳՖabc
            result: match
            options: ''
            substitution: ''
            description: "\\p{InArmenian}+ — Matches characters in the Armenian block."
          2:
            pattern: "\\P{InThai}+"
            test: Helloกส
            result: match
            options: ''
            substitution: ''
            description: "\\P{InThai}+ — Matches characters not in the Thai block."
          3:
            pattern: "\\p{^InKhmer}+"
            test: xyzខ
            result: match
            options: ''
            substitution: ''
            description: "\\p{^InKhmer}+ — Negated block: matches characters not in Khmer."
          4:
            pattern: "\\p{InCyrillic}+"
            test: ПриветX
            result: match
            options: ''
            substitution: ''
            description: "\\p{InCyrillic}+ — Matches characters in the Cyrillic block."
          5:
            pattern: "\\P{InHebrew}+"
            test: ABCשלום
            result: match
            options: ''
            substitution: ''
            description: "\\P{InHebrew}+ — Matches characters not in the Hebrew block."
      unicode-classes:
        short: Unicode Classes
        description: Binary and negated properties like Alpha, Space, Alnum.
        examples:
          0:
            pattern: "\\p{Alpha}+"
            test: Hi1!
            result: match
            options: ''
            substitution: ''
            description: "\\p{Alpha}+ — Matches one-or-more alphabetic characters."
          1:
            pattern: "\\P{Space}+"
            test: Az BC
            result: match
            options: ''
            substitution: ''
            description: "\\P{Space}+ — Matches one-or-more non-space characters."
          2:
            pattern: "\\p{^Alnum}+"
            test: abc-123?
            result: match
            options: ''
            substitution: ''
            description: "\\p{^Alnum}+ — Negated alnum: matches non-alphanumeric characters."
          3:
            pattern: "\\p{Digit}+"
            test: 123a
            result: match
            options: ''
            substitution: ''
            description: "\\p{Digit}+ — Matches one-or-more digit characters."
          4:
            pattern: "\\P{Alpha}+"
            test: 123A
            result: match
            options: ''
            substitution: ''
            description: "\\P{Alpha}+ — Matches one-or-more non-alphabetic characters."
          5:
            pattern: "\\p{Space}+"
            test: a b
            result: match
            options: ''
            substitution: ''
            description: "\\p{Space}+ — Matches one-or-more whitespace characters."
      unicode-derived:
        short: Unicode Derived
        description: Derived properties such as Math, Lowercase, Cased.
        examples:
          0:
            pattern: "\\p{Math}+"
            test: "+×= x"
            result: match
            options: ''
            substitution: ''
            description: "\\p{Math}+ — Matches math symbols and operators."
          1:
            pattern: "\\P{Lowercase}+"
            test: ABCdef
            result: match
            options: ''
            substitution: ''
            description: "\\P{Lowercase}+ — Matches non-lowercase characters."
          2:
            pattern: "\\p{^Cased}+"
            test: 123_a
            result: match
            options: ''
            substitution: ''
            description: "\\p{^Cased}+ — Negated cased property: matches non-cased characters."
          3:
            pattern: "\\p{Lowercase}+"
            test: abcD
            result: match
            options: ''
            substitution: ''
            description: "\\p{Lowercase}+ — Matches one-or-more lowercase letters."
          4:
            pattern: "\\P{Math}+"
            test: abc+=
            result: match
            options: ''
            substitution: ''
            description: "\\P{Math}+ — Matches characters that are not math symbols."
          5:
            pattern: "\\p{Alphabetic}+"
            test: ab1
            result: match
            options: ''
            substitution: ''
            description: "\\p{Alphabetic}+ — Matches alphabetic characters."
      unicode-general-categories:
        short: Unicode General Categories
        description: Categories like Lu, Cs, and negated script (sc).
        examples:
          0:
            pattern: "\\p{LU}+"
            test: ABCd
            result: match
            options: ''
            substitution: ''
            description: "\\p{LU}+ — Matches uppercase letters (one-or-more)."
          1:
            pattern: "\\p{lu}+"
            test: ABCd
            result: match
            options: ''
            substitution: ''
            description: "\\p{lu}+ — Matches lowercase letters (one-or-more)."
          2:
            pattern: "\\p{Uppercase Letter}+"
            test: ABCd
            result: match
            options: ''
            substitution: ''
            description: "\\p{Uppercase Letter}+ — Matches uppercase letters."
          3:
            pattern: "\\p{Uppercase_Letter}+"
            test: ABCd
            result: match
            options: ''
            substitution: ''
            description: "\\p{Uppercase_Letter}+ — Matches uppercase letters."
          4:
            pattern: "\\p{UPPERCASE-LETTER}+"
            test: ABCd
            result: match
            options: ''
            substitution: ''
            description: "\\p{UPPERCASE-LETTER}+ — Matches uppercase letters."
          5:
            pattern: "\\P{Lu}+"
            test: ABCd
            result: match
            options: ''
            substitution: ''
            description: "\\P{Lu}+ — Matches characters that are not uppercase letters."
          6:
            pattern: "\\p{^sc}+"
            test: 123Λ
            result: match
            options: ''
            substitution: ''
            description: "\\p{^sc}+ — matches at the start of the string."
          7:
            pattern: "\\p{Cc}+"
            test: "\x01A"
            result: match
            options: ''
            substitution: ''
            description: "\\p{Cc}+ — Matches control characters."
          8:
            pattern: "\\p{Cf}+"
            test: "‍A"
            result: match
            options: ''
            substitution: ''
            description: "\\p{Cf}+ — Matches format (invisible) characters."
      unicode-scripts:
        short: Unicode Scripts
        description: Script property match, with negation.
        examples:
          0:
            pattern: "\\p{Arabic}+"
            test: سلامHello
            result: match
            options: ''
            substitution: ''
            description: "\\p{Arabic}+ — Matches Arabic script characters."
          1:
            pattern: "\\P{Hiragana}+"
            test: ABCあいう
            result: match
            options: ''
            substitution: ''
            description: "\\P{Hiragana}+ — Matches characters not in Hiragana."
          2:
            pattern: "\\p{^Greek}+"
            test: ABCΩΔ
            result: match
            options: ''
            substitution: ''
            description: "\\p{^Greek}+ — matches at the start of the string."
          3:
            pattern: "\\p{Katakana}+"
            test: カタカナB
            result: match
            options: ''
            substitution: ''
            description: "\\p{Katakana}+ — Matches Katakana characters."
          4:
            pattern: "\\p{Cyrillic}+"
            test: ПриветX
            result: match
            options: ''
            substitution: ''
            description: "\\p{Cyrillic}+ — Matches Cyrillic script characters."
          5:
            pattern: "\\P{Devanagari}+"
            test: Helloनमस्ते
            result: match
            options: ''
            substitution: ''
            description: "\\P{Devanagari}+ — Matches characters not in Devanagari."
      unicode-simple-props:
        short: Unicode Simple Props
        description: Simple binary properties like Dash, Extender, and negation.
        examples:
          0:
            pattern: "\\p{Dash}+"
            test: "–‑—A"
            result: match
            options: ''
            substitution: ''
            description: "\\p{Dash}+ — Matches dash/hyphen-like characters."
          1:
            pattern: "\\p{Extender}+"
            test: ːX
            result: match
            options: ''
            substitution: ''
            description: "\\p{Extender}+ — Matches extender characters."
          2:
            pattern: "\\p{^Hyphen}+"
            test: word-word
            result: match
            options: ''
            substitution: ''
            description: "\\p{^Hyphen}+ — matches at the start of the string."
          3:
            pattern: "\\P{Dash}+"
            test: ABC–
            result: match
            options: ''
            substitution: ''
            description: "\\P{Dash}+ — Matches characters that are not dash-like."
          4:
            pattern: "\\p{Hyphen}+"
            test: "-B"
            result: match
            options: ''
            substitution: ''
            description: "\\p{Hyphen}+ — Matches hyphen characters."
          5:
            pattern: "\\p{Emoji}+"
            test: "\U0001F468‍\U0001F469‍\U0001F467‍\U0001F466abc"
            result: match
            options: ''
            substitution: ''
            description: "\\p{Emoji}+ — Matches emoji characters."
      posix-classes-vs-unicode-properties:
        short: POSIX vs Unicode
        description: Compare POSIX character classes and Unicode property constructs with clear match boundaries.
        examples:
          0:
            pattern: "[[:alpha:]]+"
            test: abc123XYZ
            result: match
            options: ''
            substitution: ''
            description: "[[:alpha:]]+ — matches any single character from the character class."
          1:
            pattern: "\\p{Alpha}+"
            test: abc123XYZ
            result: match
            options: ''
            substitution: ''
            description: "\\p{Alpha}+ — Matches alphabetic characters."
          2:
            pattern: "[[:^alpha:]]+"
            test: abc123XYZ
            result: match
            options: ''
            substitution: ''
            description: "[[:^alpha:]]+ — matches any single character not in the class."
          3:
            pattern: "\\P{Alpha}+"
            test: abc123XYZ
            result: match
            options: ''
            substitution: ''
            description: "\\P{Alpha}+ — Matches non-alphabetic characters."
          4:
            pattern: "[[:digit:]]+"
            test: abc123.45def
            result: match
            options: ''
            substitution: ''
            description: "[[:digit:]]+ — matches any single character from the character class."
          5:
            pattern: "\\p{Digit}+"
            test: abc123.45def
            result: match
            options: ''
            substitution: ''
            description: "\\p{Digit}+ — Matches digit characters."
          6:
            pattern: "[[:punct:]]+"
            test: hello!?
            result: match
            options: ''
            substitution: ''
            description: "[[:punct:]]+ — matches any single character from the character class."
          7:
            pattern: "\\p{Punct}+"
            test: hello!?
            result: match
            options: ''
            substitution: ''
            description: "\\p{Punct}+ — Matches punctuation characters."
          8:
            pattern: "[[:space:]]+"
            test: "a b\tc\n"
            result: match
            options: ''
            substitution: ''
            description: "[[:space:]]+ — matches any single character from the character class."
          9:
            pattern: "\\p{Space}+"
            test: "a b\tc\n"
            result: match
            options: ''
            substitution: ''
            description: "\\p{Space}+ — Matches whitespace characters."
          10:
            pattern: "[[:lower:]]+"
            test: AbC
            result: match
            options: ''
            substitution: ''
            description: "[[:lower:]]+ — matches any single character from the character class."
          11:
            pattern: "\\p{Lower}+"
            test: AbC
            result: match
            options: ''
            substitution: ''
            description: "\\p{Lower}+ — Matches lowercase letters."
          12:
            pattern: "[[:upper:]]+"
            test: AbC
            result: match
            options: ''
            substitution: ''
            description: "[[:upper:]]+ — matches any single character from the character class."
          13:
            pattern: "\\p{Upper}+"
            test: AbC
            result: match
            options: ''
            substitution: ''
            description: "\\p{Upper}+ — Matches uppercase letters."
    reference:
      click_to_copy: "Click to copy"
      quick_reference: Regex Quick Reference
      sections:
        character-classes-anchors:
          title: "Character Classes & Anchors"
          patterns:
            0: "[abc]"
            1: "[^abc]"
            2: "[a-z]"
            3: "[a-zA-Z]"
            4: "^"
            5: "$"
            6: "\\A"
            7: "\\z"
          items:
            0: "A single character of: a, b, or c"
            1: "Any single character except: a, b, or c"
            2: "Any single character in the range a-z"
            3: "Any single character in the range a-z or A-Z"
            4: "Start of line"
            5: "End of line"
            6: "Start of string"
            7: "End of string"
        common-patterns:
          title: "Common Patterns"
          patterns:
            0: "."
            1: "\\s"
            2: "\\S"
            3: "\\d"
            4: "\\D"
            5: "\\w"
            6: "\\W"
            7: "\\b"
          items:
            0: "Any single character"
            1: "Any whitespace character"
            2: "Any non-whitespace character"
            3: "Any digit"
            4: "Any non-digit"
            5: "Any word character (letter, number, underscore)"
            6: "Any non-word character"
            7: "Any word boundary"
        groups-quantifiers:
          title: "Groups & Quantifiers"
          patterns:
            0: "(...)"
            1: "(a|b)"
            2: "a?"
            3: "a*"
            4: "a+"
            5: "a{3}"
            6: "a{3,}"
            7: "a{3,6}"
          items:
            0: "Capture everything enclosed"
            1: "a or b"
            2: "Zero or one of a"
            3: "Zero or more of a"
            4: "One or more of a"
            5: "Exactly 3 of a"
            6: "3 or more of a"
            7: "Between 3 and 6 of a"
      options:
        options_label: "Options:"
        i: "case insensitive"
        m: "make dot match newlines"
        x: "ignore whitespace in regex"
    footer:
      inspired_by: Inspired by Michael Lovitt’s excellent
      rubree_uses_ruby: "Rubree uses Ruby %{version}"
      issues_text: "Issues"
      issues_handle: "rubree"
      made_by: "Made by Takashi Shimokawa"
      made_by_handle: "@aim2bpg"
